import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.ArrayList;

public class FunWithThreads {
  
		final Disk disk = new Disk();
		final Args args;
		int        val[];
  
		/** 
		 * Simple constructor sets the passed arguments.
		 */
		FunWithThreads ( String argsStrings[] ) {
				args = new Args ( getClass().getName(), argsStrings, Option.values() );
		}
  
		/**
		 * Command Line Arguments
		 */
		enum Option implements Args.OptionReferrer {    
				SEQUENTIAL ("-sequential",       "Select sequential implementation"), 
				THREADS    ("-threads",          "Select thread-based implementation"), 
				EXECUTOR   ("-executor",   null, "Select executor implementation where n is number of threads"),
				VERBOSE    ("-verbose",          "Print values generated by read"),
				COUNT      ("-count",      1000, "Number of reads to perform");

				final Args.Option option;
				Option ( String str, String dsc)               { option = new Args.Option( str, dsc ); }
				Option ( String str, Integer dfl, String dsc ) { option = new Args.Option( str, dfl, dsc ); }
				public Args.Option getOption()                 {return option;}
		}
  
		/**
		 * Called by main to run the class.
		 */
		void run() throws Args.UsageException, InterruptedException {
				int readCount = args.intValue (Option.COUNT);
				val           = new int [readCount];

				if ( args.contains ( Option.SEQUENTIAL ) ) {
						System.out.printf( "Performing %d reads sequentially.\n", readCount );
						sequential( readCount );
				} else if ( args.contains( Option.THREADS ) ) {
						System.out.printf( "Performing %d reads in separate threads.\n", readCount );
						threaded( readCount );
				} else if ( args.contains( Option.EXECUTOR ) ) {
						int threadCount = args.intValue( Option.EXECUTOR );
						System.out.printf( "Performing %d reads using thread-pool executor with %d threads.\n", 
								readCount, threadCount );
						executor( readCount, threadCount );
				} else {
						throw args.new UsageException();
				}

				if ( args.contains ( Option.VERBOSE ) ) {
						for ( int i = 0; i < readCount; i++ )
								System.out.printf( "(%d %d)\n", val[i] >> 16, val[i] & 0xffff );
				}
		}
  
		/**
		 * Execution starts with main, which creates instance of class and calls run.
		 */
		public static void main ( String[] args ) {
				try {
						(new FunWithThreads (args)).run ();
				} catch ( Args.UsageException ue ) {
						System.out.print (ue.getMessage());
				} catch ( InterruptedException ie ) {
						System.out.println( "Interruped Exception thrown." );
				}
		}
  
		/**
		 * Performs disk reads sequentially.
		 * @param readCount number of reads to perform
		 */
		void sequential ( int readCount ) {
				for ( int i = 0; i < readCount; i++ )
						val[i] = disk.read( i );
		}
  
		/**
		 * Class for disk read using Thread.
		 */
		private class ReadRunnable implements Runnable {
				int result, arg;

				/** Constructor: Set the argument for disk read. */
				public ReadRunnable ( int arg ) { this.arg = arg; }	

				/** Run calls disk read with the given argument. */
				public void run() { result = disk.read( arg ); }
		}

		/**
		 * Perform disk reads using separate thread for each read.
		 *
		 * @param  readCount            number of reads to perform
		 * @throws InterruptedException if join is interrupted    
		 */
		void threaded ( int readCount ) throws InterruptedException {
				Thread[]   reads = new Thread[readCount];
				ReadRunnable[] r = new ReadRunnable[readCount];

				// Schedule disk reading threads.
				for ( int i = 0; i < readCount; i++ ) {
						r[i]     = new ReadRunnable( i );
						reads[i] = new Thread( r[i] );
						reads[i].start();
				}

				// Join disk reading threads.
				for ( int i = 0; i < readCount; i++ ) {
						try {
								reads[i].join();
								val[i] = r[i].result;
						} catch ( InterruptedException ie ) {
								System.err.println( "Couldn't join." );
						}
				}
		}
  
		/**
		 * Class for disk read using Executor.
		 */
		private class ReadCallable implements Callable<Integer> {
				int arg;

				/** Constructor: Set the argument for disk read. */
				public ReadCallable ( int arg ) { this.arg = arg; }

				/** Return result of disk read with given argument. */
				public Integer call () { return disk.read( arg ); }
		}
 
		/**
		 * Perform disk reads using thread-pool executor.
		 *
		 * @param  readCount            number of reads to perform
		 * @param  threadCount          number of threads in the thread pool
		 * @throws InterruptedException if future-value wait is interrupted    
		 */
		void executor ( int readCount, int threadCount ) throws InterruptedException {
				ArrayList <Future <Integer>> futureVals = new ArrayList <Future <Integer>>();
				ExecutorService exec = Executors.newFixedThreadPool( threadCount );

				// Schedule disk reading threads.
				for ( int i = 0; i < readCount; i++ ) {
						futureVals.add( exec.submit( new ReadCallable( i ) ) );
				}

				// Join disk reading threads.
				for ( int i = 0; i < readCount; i++ ) {
						try {
								val[i] = futureVals.get( i ).get();
						} catch ( InterruptedException ie ) {
								System.err.println( "Couldn't join." );
						} catch ( ExecutionException ee ) {
								System.err.println( "Execution exeption." );
						}
				}

				exec.shutdown();
		}
  
		/**
		 * Crude implementation of disk.
		 */
		static class Disk {
				int count = 0;

				/**
				 * Simulate a synchronous disk read by waiting 10ms before returning.
				 *
				 * @param req request sequence number
				 * @return    processing sequence number << 16 | request sequence number
				 */
				public int read ( int req ) {
						try {
								Thread.sleep (10);  
						} catch ( InterruptedException ie ) {
								assert false;
						}
						return (count++)<<16 | req;
				}
		}
  
		/**
		 * Procsss command line arguments
		 */
		static class Args {
				String           mainClassName;
				String[]         args;
				OptionReferrer[] optionReferrers;

				/**
				 * Create args instance.
				 *
				 * @param args array of command line argument strings.
				 */
				Args (String mainClassName, String[] args, OptionReferrer[] optionReferrers) {
						this.mainClassName	 = mainClassName; 
						this.args			 = args; 
						this.optionReferrers = optionReferrers;
				}
    
				/** 
				 * Contains a reference to an option.  Useful to allow enums to describe an option, 
				 * because enums can not extend a class and thus can not extend Args.Option, which 
				 * would be the desired behaviour.
				 */
				interface OptionReferrer {
						public Option getOption();
				}
     
				/**
				 * Description of a command-line option.
				 */
				static class Option {
						enum Type {BOOLEAN, INTEGER};
      
						final String string;
						final Type   type;
						final Object defaultValue;
						final String description;
      
						Option ( String string, String description ) {
								this.string = string; 
								this.type   = Type.BOOLEAN; 
								this.defaultValue = null; 
								this.description  = description;
						}

						Option ( String string, Integer defaultValue, String description ) {
								this.string = string; 
								this.type = Type.INTEGER; 
								this.defaultValue = defaultValue; 
								this.description = description;
						}
				}
    
				/**
				 * Deterine whether command line argumnets contain specified option.
				 *
				 * @param  option option to check
				 * @return        true iff option.string is on the command line
				 */
				boolean contains ( OptionReferrer optionReferrer ) {
						Option option = optionReferrer.getOption();
						for (int i = 0; i < args.length; i++ ) {
								if ( option.string.startsWith( args[i] ) )
										return true;
						}
						return false;
				}
    
				/**
				 * Get the int value of specified command line argument, if present and if int value allowed.
				 *
				 * @param option          option to check
				 * @return                value provided on command line for specified option
				 * @throws UsageException if option is not present, if it does not allow a value, 
				 *                        or if command-line value is missing or malformed
				 */
				int intValue ( OptionReferrer optionReferrer ) throws UsageException {
						Option option = optionReferrer.getOption();
						if ( option.type==Option.Type.INTEGER ) {
								for ( int i = 0; i < args.length; i++ ) {
										if ( option.string.startsWith( args[i] ) ) {
												try {
														return Integer.valueOf( args[i+1] );
												} catch ( ArrayIndexOutOfBoundsException aioobe ) {
														throw new UsageException();
												} catch ( NumberFormatException nfe ) {
														throw new UsageException();
												}
										}
								}

								if ( option.defaultValue != null )
										return (Integer) option.defaultValue;
								else
										throw new UsageException();
						} else
								throw new UsageException();
				}
    
				/**
				 * An exception used to indicate a command-line sytax error whose message value is the 
				 * usage string.
				 */
				class UsageException extends Exception {
						@Override public String getMessage() {
								String str = String.format( "usage: java %s ", mainClassName );
								int    maxLength = 0;

								for ( OptionReferrer opRef : optionReferrers ) {
										Option op  = opRef.getOption();
										String opt = op.string;
										maxLength  = Math.max( maxLength, op.string.length() );

										switch (op.type) {
												case INTEGER:
														opt = opt.concat( " n" );
														break;
												default:
										}

										str = str.concat( opt.concat (" ") );
								}

								str = str.concat( "\n" );
								String fmt = String.format("    %%-%ds %%s", maxLength );
								for ( OptionReferrer opRef : optionReferrers ) {
										Option op  = opRef.getOption();
										String lin = String.format( fmt, op.string, op.description );

										if ( op.defaultValue != null ) {
												switch ( op.type ) {
														case INTEGER:
																lin = lin.concat( String.format( " (default %d)", 
																		(Integer) op.defaultValue ) );
																break;
														default:
												}
										}

										str = str.concat (lin.concat ("\n"));
								}

								return str;        
						}
				}
		}
}

